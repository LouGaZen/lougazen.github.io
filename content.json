{"meta":{"title":"Apocalypse","subtitle":null,"description":null,"author":"LouGaZen","url":"http://lougazen.github.io"},"pages":[{"title":"categories","date":"2018-12-05T04:44:25.000Z","updated":"2019-12-23T04:00:43.925Z","comments":false,"path":"categories/index.html","permalink":"http://lougazen.github.io/categories/index.html","excerpt":"","text":""},{"title":"tags","date":"2018-12-05T03:49:41.000Z","updated":"2019-12-23T04:00:43.925Z","comments":false,"path":"tags/index.html","permalink":"http://lougazen.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"记一次kubernetes节点内存占用过高问题排查","slug":"记一次kubernetes节点内存占用过高问题排查","date":"2021-03-08T08:44:42.000Z","updated":"2021-03-08T09:37:54.906Z","comments":true,"path":"2021/03/08/记一次kubernetes节点内存占用过高问题排查/","link":"","permalink":"http://lougazen.github.io/2021/03/08/记一次kubernetes节点内存占用过高问题排查/","excerpt":"","text":"序公司的应用服务通过kubernetes集群部署的，集群包含5个节点。最近其中一节点占用一直维持95%，遂进行问题排查。 问题排查容器的问题？首先先把该机器设置为”不可调度”（防止后续操作死灰复燃），然后将部分内存占用高的调度到其他机器上（如nginx-ingress） 收效甚微 内存确实降下来了（一点点😅），起码先不用频繁触发报警 kubernetes的问题？因为节点是购买自阿里云的ECS，且这些节点无法远程登录，排查工作一度暂停。后来换用了Lens对集群进行管理后发现可以轻松登录节点进行操作了。 Lens - Nodes 进入shell之后执行top命令然后按大写M查看内存占用最高的服务，看到了rsyslogd（当时忘了截图了） Google了一番后得知rsyslog是日志收集服务，主要是通过以下文件收集 路径 描述 /var/log/messages 服务信息日志(记录linux操作系统常见的服务信息和错误信息) /var/log/secure 系统的登陆日志(记录用户和工作组的变化情况,是系统安全日志，用户的认证登陆情况 /var/log/maillog 邮件日志 /var/log/cron 定时任务 /var/log/boot.log 系统启动日志 然后tail -f /var/log/messages一下，好家伙，日志一直刷刷刷的跑 12345678kubelet_volumes.go:128] Orphaned pod &quot;***&quot; found, but volume paths are still present on disk. : There were a total of 1 errors similar to this. Turn up verbosity to see them....systemd[1]: Scope libcontainer-***-systemd-test-default-dependencies.scope has no PIDs. Refusing.systemd[1]: Scope libcontainer-***-systemd-test-default-dependencies.scope has no PIDs. Refusing.systemd[1]: Created slice libcontainer_***_systemd_test_default.slice.systemd[1]: Removed slice libcontainer_***_systemd_test_default.slice.systemd[1]: Created slice libcontainer_***_systemd_test_default.slice.systemd[1]: Removed slice libcontainer_***_systemd_test_default.slice. （大致恢复了事故现场，截图丢了） 再Google一番后里面这里有两个问题待解决 僵尸Pod出现Orphaned pod &quot;***&quot; found就是僵尸Pod的问题了，一般是因为删除容器的时候没删干净，导致配置文件残留在节点机器上，k8s就会不断尝试给它复活但是基本上会复活失败 进入/var/lib/kubelet/***，然后cat etc-host看一下该容器的名字，然后去kubectl get pods | grep （容器名字）看是否还在（一般都是不在的了） 然后对文件夹进行删除（如有mount volume之类的要先unmount，我这里没有mount所以可以直接删掉） 好了，现在看日志就没有kubelet_volumes.go的报错了 内置container组件问题看这里的描述k8s 问题处理似乎是container版本过旧或者不兼容，按他的说法去更新一下就好了 1rpm -Uvh https://download.docker.com/linux/centos/7/x86_64/edge/Packages/containerd.io-1.2.10-3.2.el7.x86_64.rpm 如果是用Lens去登录节点的话更新过程会断开连接，不要慌，过一会而就能重连了。 执下手尾处理完后看看tail -f /var/log/messages，此时没有疯狂刷日志了，但rsyslogd的内存占用还没下来，遂进行网管必备的重启大法 1systemd restart rsyslog.service 此时再看top，内存占用最高的不是它了 再去阿里云的监控看看，内存占用暴跌至正常水平😄 会心一击 鸣谢 rsyslogd、systemd-journald内存占用高解决方案挂载失败-日志中显示僵尸pod的问题k8s关于Orphaned pod found - but volume paths are still present on disk的处理k8s 问题处理","categories":[],"tags":[]},{"title":"golang简单websocket demo及nginx转发事要","slug":"golang简单websocket-demo及nginx转发事要","date":"2020-03-04T11:57:25.000Z","updated":"2020-03-04T12:44:39.205Z","comments":true,"path":"2020/03/04/golang简单websocket-demo及nginx转发事要/","link":"","permalink":"http://lougazen.github.io/2020/03/04/golang简单websocket-demo及nginx转发事要/","excerpt":"","text":"序最近一个项目上用到消息推送功能，boss说写个简单的ws让前端自行处理消息就好（前端：MMP）。看到网上用到比较多的框架是gorilla/websocket，但是要验证第三方包的稳定性还是需要一定时间，还是用官方的websocket包吧（又不是不能用.jpg）。思路其实很简单，\b一端接收到消息之后直接推入一个channel。另启一个协程去接收这个channel的消息，然后广播到所有ws连接。 Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112package mainimport ( \"context\" \"log\" \"net/http\" \"sync\" \"golang.org/x/net/websocket\")var ( // WsSrv - WsSrv *WsServer)const ( // MessageChanSize - MessageChanSize = 1024)// WsServer -type WsServer struct &#123; Clients map[string]*WsClient MessageChan chan string Codec websocket.Codec sync.RWMutex&#125;// ClientConn -type WsClient struct &#123; websocket *websocket.Conn&#125;// InitWsServer -func InitWsServer() &#123; WsSrv = &amp;WsServer&#123; Clients: map[string]*WsClient&#123;&#125;, MessageChan: make(chan string, MessageChanSize), Codec: websocket.Message, &#125;&#125;// WsReceiver -func WsReceiver(ws *websocket.Conn) &#123; var ( msg string err error ) defer func() &#123; if err = ws.Close(); err != nil &#123; log.Printf(\"[WsReceiver] ws(%v) closed err: %v\\n\", ws.RemoteAddr(), err) &#125; &#125;() userID := ws.Request().URL.Query().Get(\"user_id\") if userID == \"\" &#123; return &#125; defer func() &#123; WsSrv.Lock() defer WsSrv.Unlock() delete(WsSrv.Clients, userID) &#125;() WsSrv.Lock() WsSrv.Clients[userID] = &amp;WsClient&#123;websocket: ws&#125; WsSrv.Unlock() for &#123; if err = WsSrv.Codec.Receive(ws, &amp;msg); err != nil &#123; log.Printf(\"[WsReceiver] receive from remote result err: %v\\n\", err) return &#125; WsSrv.MessageChan &lt;- msg &#125;&#125;// WsSender -func WsSender(ctx context.Context) &#123; var err error for &#123; select &#123; case msg := &lt;-WsSrv.MessageChan: for userID, conn := range WsSrv.Clients &#123; if err = websocket.Message.Send(conn.websocket, msg); err != nil &#123; log.Printf(\"[WsSender] send msg(%v) to user_id(%v) result err: %v\\n\", msg, userID, err) &#125; &#125; case &lt;-ctx.Done(): return &#125; &#125;&#125;func main() &#123; var err error InitWsServer() go WsSender(context.Background()) mux := http.NewServeMux() mux.Handle(\"/im\", websocket.Handler(WsReceiver)) mux.HandleFunc(\"/ping\", func(writer http.ResponseWriter, request *http.Request) &#123; _, _ = writer.Write([]byte(\"pong\")) &#125;) if err = http.ListenAndServe(\":23333\", mux); err != nil &#123; log.Fatalln(err) &#125;&#125; nginx转发事要在http请求升级为ws请求的过程中会带着两个重要的header，一个是Upgrade: websocket，另一个是Connection: upgrade。只有带上这两个header才能在http/1.1下成功将http请求升级为ws请求，但是如果在服务器中有nginx反向代理的情况下往往会把这个头丢掉，所以要在配置文件上加上来，否则会出现著名的http状态码400错误 1234567891011121314151617181920map $http_upgrade $connection_upgrade &#123; default upgrade; \"\" close;&#125;upstream srv &#123; server 127.0.0.1:23333;&#125;server &#123; listen 80; location ~ ^/im &#123; proxy_pass http://srv; proxy_http_version 1.1; proxy_set_header Upgrade $http_upgrade; proxy_set_header Connection $connection_upgrade; proxy_set_header Host $host; &#125;&#125; 鸣谢 golang websocket的例子Using NGINX as a WebSocket Proxywebsocket 在线测试工具wscat","categories":[],"tags":[]},{"title":"iPhone 5s降级iOS 10.3.3简要备忘","slug":"iPhone-5s降级iOS-10-3-3简要备忘","date":"2020-03-02T05:04:07.000Z","updated":"2020-03-02T05:53:24.235Z","comments":true,"path":"2020/03/02/iPhone-5s降级iOS-10-3-3简要备忘/","link":"","permalink":"http://lougazen.github.io/2020/03/02/iPhone-5s降级iOS-10-3-3简要备忘/","excerpt":"","text":"序好像好久都没有更新博客了，还是要养成做记录的习惯。 偶然看到5s可以降级iOS 10.3.3的帖子，二话不说GKD。中途遇到一些问题在此做个备忘 准备 1.一台正常运行的iPhone 5s 2.macOS with python3 environment 3.科学上网 正式开始 1.到https://github.com/MatthewPierson/Vieux把降级脚本克隆下来，然后去https://ipsw.me下载对应型号的iOS 10.3.3固件到脚本所在目录 2.执行sudo pip3 install -r requirement.txt安装所需包（可能需要科学上网） 3.手机连上电脑进入DFU模式（如何进入DFU可以看这里） 3.执行sudo python3 vieux -i ➕上固件所在路径 4.等待脚本撞bug。按照漏洞发现者的说法这个漏洞并不是100%成功，没有撞成功重试即可，成功的标志是手机闪一下绿屏。绿屏过后就会自己恢复10.3.3固件 奇难杂症No Module Found 这个我是感觉最坑爹的地方，pip3安装说成功，pip3 list也有list出来，但是执行的时候却报错，一看pip3 --version下巴都掉了 坑 爬了一下google，发现pip的命令可以用python3 -m pip ...代替，所以上述第二步的安装环境可以执行sudo python3 -m pip install -r requirements.txt No Backend Available 这个一开始以为是包的问题，用pip install补上后发现问题依旧，然后去脚本仓库找有没有相关的issue，嚯还真有，解决办法是通过brew安装，即brew install libusb 鸣谢 5s降级10.3.3不是很难，就是需要仔细，你就可以完成降级Vieux - A tool for 32/64 Bit iOS downgrades using OTA BlobsWhy pip3 install in python2 sitepackages使用 Vieux 将 iphone5s 降级到 10.3.3iPhone 4 / 4S / 5 / 5S / 5c / 6 / 6S - 如何在DFU模式刷机。密码恢复。","categories":[],"tags":[]},{"title":"入手一台服务器后的一些必备操作","slug":"入手一台服务器后的一些必备操作","date":"2019-12-23T08:17:24.000Z","updated":"2020-03-09T07:31:08.019Z","comments":true,"path":"2019/12/23/入手一台服务器后的一些必备操作/","link":"","permalink":"http://lougazen.github.io/2019/12/23/入手一台服务器后的一些必备操作/","excerpt":"","text":"序无意中看到腾讯云服务器的活动（Pony麻烦结一下广告费谢谢），趁着现在还不够25岁赶紧续了3次每次最多续1年 Pony Ma亏得都要坐公交了 修改root密码拿到服务器第一步就是把默认那个又长又难记的密码改掉 在命令行执行passwd passwd 修改成功后记得新开个tab测试新密码能否登陆再退出当前会话 配置服务器免密登陆ssh-keygen先查看本机有没有生成过ssh的公钥和私钥 12cd ~/.sshls -al 公钥和私钥 红框中的两个文件分别存放着私钥和公钥，如果没有这两个文件就按以下步骤来 执行ssh-keygen然后按三下回车 ssh-keygen 现在再去查看就有公钥的信息了 id_rsa.pub 然后把这段公钥上传到目标服务器的~/.ssh/authorized_keys文件当中 authorized_keys 测试一下，现在可以不用密码顺利登陆进来了 免密登陆 ！！！注意：万一电脑丢失记得上服务器把该机器的公钥删掉 防火墙服务器到手的时候自带了firewalld但是并没有启动，使用firewall-cmd --state命令可以查看firewall的运行状态 firewall-cmd --state 12systemctl enable firewalld # 启用自动启动systemctl start firewalld # 启动 成功的话再次查看状态会显示running 把常用的服务和端口加入允许列表 123firewall-cmd --permanent --zone=public --add-service=httpfirewall-cmd --permanent --zone=public --add-service=httpsfirewall-cmd --reload 修改ssh默认端口稍有常识的人 众所周知ssh默认端口是22，如果不加以修改很容易被人攻击 一夜过后被尝试889次登录 （题外话使用lastb命令可以查看尝试登录的客户端信息，如果信息太多则lastb &gt; fail.log重定向到本地文件再查看） ssh端口的配置存放在/etc/ssh/sshd_config中，直接在# Port 22下一行添加 script12Port 22Port （你目标的端口） sshd_config 加上22端口是防止现在的连接失效，万一你添加的端口被防火墙屏蔽的那就gg了 然后再添加个防火墙允许规则 12firewall-cmd --zone=public --add-port=（你目标的端口）/tcp --permanentfirewall-cmd --reload 重启ssh服务 1systemctl restart sshd.service 不要关闭当前连接，新开个tab尝试能否连接成功，成功后再去把22端口删掉 端口修改后跟ssh相关的命令要带端口参数 123ssh root@xxx.xx -p 123sftp -P 123 root@xxx.xxscp -P 123 ...... 安装docker按照官方的文档把下面命令执行一遍就行了 123456sudo yum remove docker docker-client docker-client-latest docker-common docker-latest docker-latest-logrotate docker-logrotate docker-engineyum install -y yum-utils device-mapper-persistent-data lvm2yum-config-manager --add-repo https://download.docker.com/linux/centos/docker-ce.repoyum install docker-ce docker-ce-cli containerd.iosystemctl enable dockersystemctl start docker 使用docker启动nginx首先在srv目录创建文件夹，用于放置ssl证书及nginx配置文件 1mkdir -p /srv/nginx-data/conf/cert 把申请到的证书放在/srv/nginx-data/conf/cert目录下 在/srv/nginx-data/conf目录下创建一个index.conf的文件，内容如下 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768# 使非www域名自动跳转到带www的域名server &#123; listen *:80; listen *:443 ssl http2; listen [::]:80; listen [::]:443 ssl http2; server_name 自己的域名; ssl_certificate SSL证书; ssl_certificate_key SSL证书; return 301 https://www.自己的域名$request_uri;&#125;# 使http自动跳转到httpsserver &#123; listen *:80; listen [::]:80; server_name www.自己的域名; return 301 https://www.自己的域名$request_uri;&#125;server &#123; listen *:443 ssl http2; listen [::]:443 ssl http2; server_name www.自己的域名; ssl_certificate SSL证书; ssl_certificate_key SSL证书; #charset koi8-r; #access_log /var/log/nginx/host.access.log main; location / &#123; root /usr/share/nginx/html; index index.html index.htm; &#125; #error_page 404 /404.html; # redirect server error pages to the static page /50x.html # error_page 500 502 503 504 /50x.html; location = /50x.html &#123; root /usr/share/nginx/html; &#125; # proxy the PHP scripts to Apache listening on 127.0.0.1:80 # #location ~ \\.php$ &#123; # proxy_pass http://127.0.0.1; #&#125; # pass the PHP scripts to FastCGI server listening on 127.0.0.1:9000 # #location ~ \\.php$ &#123; # root html; # fastcgi_pass 127.0.0.1:9000; # fastcgi_index index.php; # fastcgi_param SCRIPT_FILENAME /scripts$fastcgi_script_name; # include fastcgi_params; #&#125; # deny access to .htaccess files, if Apache's document root # concurs with nginx's one # #location ~ /\\.ht &#123; # deny all; #&#125;&#125; 完成后执行以下命令启动docker版nginx 1docker run -d --restart=always --name nginx -v /srv/nginx-data/conf:/etc/nginx/conf.d:ro -p 80:80 -p 443:443 nginx 其中一些参数的含义如下： -d代表后台运行 --restart=always代表docker启动的时候该container也一起启动 -name给该容器命名方便管理 -v映射目录，格式host目录:container目录(:ro)，ro代表只读（read-only） -p开放指定端口，格式host端口:container端口 如果要修改nginx的配置文件，一般都要执行nginx -t测试和nginx -s reload来使生效，而在docker下就要执行 12docker exec nginx /usr/sbin/nginx -tdocker exec nginx /usr/sbin/nginx -s reload Update: 2020-03-09 使用Ghost搭建博客平台迫于域名备案需要域名能够正常访问并且网站上有相应的备案号信息，就先用Ghost弄个博客平台应付者先。安装的方式还是使用docker，用docker就能很好将各个软件的运行环境隔离开来 安装Ghost直接执行docker run -d --name ghost --restart=always -e url=https://你的域名 ghost 添加nginx配置文件12345678910111213location / &#123; proxy_redirect off; proxy_pass http://172.17.0.5:2368; proxy_no_cache 1; proxy_http_version 1.1; proxy_set_header X-Real-IP $remote_addr; proxy_set_header Host $host; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; proxy_set_header Upgrade $http_upgrade; proxy_set_header Connection $connection_upgrade; proxy_set_header X-Forwarded-Proto $scheme; client_max_body_size 2000m;&#125; 其中两个重点： nginx反代的目标ip地址因为nginx与ghost是两个不同的环境，docker下的nginx访问宿主机的ip也比较麻烦，万幸在docker同一网络下运行的容器是可以互通的，所以只要拿到ghost的ip地址就行。然鹅事情并没有那么简单，很多容器的运行环境都是十分精简的，精简到ifconfig命令都莫得。好在docker也有命令docker inspect 容器名字/ID去获取这些信息。 docker inspect X-Forwarded-Protonginx的配置文件需要带上proxy_set_header X-Forwarded-Proto $scheme;这个header，否则就会出现无限重定向。 添加footer以上这些都弄好后访问域名应该就能顺利打开Ghost了。Ghost的默认管理域名是https://你的域名/ghost，进入后完成一系列初始化设置，在左侧点击Code injection就能添加footer 123&lt;div style=\"padding: 0 0 20px; background:#090a0b; text-align: center;\"&gt; &lt;a href=\"http://www.beian.miit.gov.cn\" target=\"_blank\" style=\"color: hsla(0,0%,100%,.7);\"&gt;粤ICP备xx号&lt;/a&gt;&lt;/&lt;div&gt; footer 鸣谢 4.3 服务器上的 Git - 生成 SSH 公钥firewall-cmdCentos7 修改SSH 端口Get Docker Engine - Community for CentOSghost - Docker Hubnginx - 安装在Docker上的Ghost使用环境变量配置了URL后无法访问,“重定向次数过多”","categories":[],"tags":[]},{"title":"通过brew cask安装指定版本的应用","slug":"通过brew-cask安装指定版本的应用","date":"2019-12-17T14:58:25.000Z","updated":"2019-12-23T04:00:43.925Z","comments":true,"path":"2019/12/17/通过brew-cask安装指定版本的应用/","link":"","permalink":"http://lougazen.github.io/2019/12/17/通过brew-cask安装指定版本的应用/","excerpt":"","text":"序最近在全新安装DataGrip(2019.3)的时候发现使用以前的洗白工具无法输入序列号，但是从2019.2版本升上来的idea和webstorm却能正常使用。作为一名idea系列的重度使（bai）用（piao）者实在是难受，首先想到的办法就是安装一个旧版本的DataGrip。但是Cask却不像Formulae通过一个@就能指定版本号，需要另辟蹊径。 准备工作先把DataGrip完全卸载 卸载DataGrip 然后执行一波brew update避免待会配置文件被覆盖 寻找旧版应用的版本号及sha256信息对于大多数开发工具来说官网都会给出旧版的软件版本号或者下载地址等其他信息，如果有sha256值提供就在好不过了，可惜DataGrip没有给出，只好下载回来自己算sha256 下载目标版本的DataGrip 计算哈希 替换目标软件的Cask下载源地址执行brew cask edit datagrip就会在默认编辑器打开这个软件的配置文件 brew cask edit datagrip 我们主要改的是红框中的两个信息，把它替换成指定版本的应用信息，保存退出 修改版本号和哈希 修改版本号和哈希 很明显这个配置文件所在的目录是个git仓库，所以改错了不用怕，到时候一波git reset --hard即可复原 执行安装命令这个时候执行brew cask install datagrip，顺利的话就会自动下载旧版本并且顺利安装 brew cask install datagrip 鸣谢 Use Homebrew Cask to downgrade or install specific version of package","categories":[],"tags":[]},{"title":"打造Mac下舒适的终端","slug":"打造Mac下舒适的终端","date":"2019-12-12T15:54:46.000Z","updated":"2019-12-23T04:00:43.924Z","comments":true,"path":"2019/12/12/打造Mac下舒适的终端/","link":"","permalink":"http://lougazen.github.io/2019/12/12/打造Mac下舒适的终端/","excerpt":"","text":"序拖延症拖了一年终于要开始打造自己的博客了(´ཀ`」 ∠)，先拿最近捣鼓的zsh开刀吧 准备brew、iTerm2和Oh-My-Zsh 使用brew安装nerd-font字体 script12brew tap caskroom/fontsbrew cask install font-hack-nerd-font 配置iTerm2针对非ASCII码字符的字体 配置iTerm2针对非ASCII码字符的字体 配置zsh主题zsh的配置文件存放在~/.zshrc下，看到 1ZSH_THEME=\"robbyrussell\" 这一行，这里就是配置主题的地方，默认自带一堆主题放在~/.oh-my-zsh/theme目录下，也可以上github上查看各个主题的效果 当然个人感觉最叼的还是这个powerlevel9k主题 powerlevel9k主题 首先把主题安装到本地 script1git clone https://github.com/bhilburn/powerlevel9k.git ~/.oh-my-zsh/custom/themes/powerlevel9k 修改~/.zshrc的主题配置 1ZSH_THEME=\"powerlevel9k/powerlevel9k\" 重新加载zsh使配置生效 script1source ~/.zshrc 然后提示就变样了（先忽略苹果logo的信息，后面会提到） 安装powerlevel9k 根据自己的喜好配置一下（注意需要加在ZSH_THEME的前面，不然前面说的nerd-font字体会加载不出来），详细可进入p9k的github阅读原文档 1234POWERLEVEL9K_MODE=\"nerdfont-complete\"POWERLEVEL9K_LEFT_PROMPT_ELEMENTS=(os_icon root_indicator context ssh dir_writable dir vcs status)POWERLEVEL9K_RIGHT_PROMPT_ELEMENTS=()POWERLEVEL9K_PROMPT_ADD_NEWLINE=true POWERLEVEL9K_MODE：设置 powerlevel9k 的字体是我们前面下载的 POWERLEVEL9K_LEFT_PROMPT_ELEMENTS：将前面居右的几个元素放在左边了 POWERLEVEL9K_RIGHT_PROMPT_ELEMENTS：右边不放置任何元素（如果你喜欢在右边也可以加） POWERLEVEL9K_PROMPT_ADD_NEWLINE：在每个提示之前添加换行符 修改完的效果应该是这样子的 配置powerlevel9k 配置iTerm2配色iTerm2默认黑色还是太丑了，上这里挑了个Ubuntu主题 iTerm2配色 啊舒服了٩(๑´0`๑)۶ 安装zsh插件以上那些都是过眼隐的，真正让使用者感到舒服的地方来了 先列一下我的插件列表 git zsh-syntax-highlighting zsh-autosuggestions command-not-found zsh_reload git-open z safe-paste sudo extract git默认自带，不说 zsh-syntax-highlighting用于显示你当前输入的命令是否正确 script1brew install zsh-syntax-highlighting 正常来讲可以直接把zsh-syntax-highlighting加到配置文件中即可启用，如果出现plugin not found的情况则改用如下方式进行配置 1source /usr/local/share/zsh-syntax-highlighting/zsh-syntax-highlighting.zsh zsh-autosuggestions历史记录提示，按➡️方向键自动补全 script1brew install zsh-autosuggestions 跟上一个配置同理，如果出现plugin not found的情况则改用如下方式进行配置 1source /usr/local/share/zsh-autosuggestions/zsh-autosuggestions.zsh command-not-found对于command not found的结果会提示一个相似的命令（多出现于拼写错误） zsh_reload直接执行src即可完成source ~/.zshrc操作 git-open在终端里打开当前项目的远程仓库地址 script1git clone https://github.com/paulirish/git-open.git $ZSH_CUSTOM/plugins/git-open zzsh自带的autojump safe-paste顾名思义，对于有换行符的内容不会立马执行 sudo双击 Esc，zsh 会把上一条命令加上 sudo 给你 extract万能解压命令 其他非zsh的插件colorls列出文件时带图标 script1gem install colorls colorls 然后加个alias到配置文件 1alias cll='colorls -l --gs' 以后输入cll即可 archey显示系统信息 script1brew install archey archey 然后把archey这个命令加到配置文件即可每次打开都显示系统信息 顺带提一下archey那种图案的生成方式，有两个小工具可以做到，一个是figlet，另一个是toilet script12brew install figletbrew install toilet figlet与toilet 后记（挖坑）这一套下来在iTerm下面使用简直是强无敌，但是考虑还有系统自带的终端及idea和vscode的终端都要配置一遍是在是烦躁，在寻找有没有办法针对不同的shell加载不同的配置文件 （2019-12-22填坑）针对不同终端使用不同的主题通过查看archey发现，终端软件（不是shell）的信息存放在${TERM_PROGRAM}这个变量里，遂修把配置文件中ZSH_THEME=&quot;powerlevel9k/powerlevel9k&quot;这一行改为 123456789if [ \"$&#123;TERM_PROGRAM&#125;\" = \"iTerm.app\" ]; then POWERLEVEL9K_MODE=\"nerdfont-complete\" POWERLEVEL9K_LEFT_PROMPT_ELEMENTS=(os_icon root_indicator context ssh dir_writable dir vcs status) POWERLEVEL9K_RIGHT_PROMPT_ELEMENTS=() POWERLEVEL9K_PROMPT_ADD_NEWLINE=true ZSH_THEME=\"powerlevel9k/powerlevel9k\"else ZSH_THEME=\"ys\"fi （顺便把powerlevel9k的一些配置也放到了一起） 最终效果 自带Terminal和vscode iTerm 完美 👏 鸣谢 打造 Mac 下高颜值好用的终端环境oh-my-zshpowerlevel9kiTerm2-Color-Schemes","categories":[],"tags":[]},{"title":"Hello World","slug":"hello-world","date":"2018-12-05T14:21:31.000Z","updated":"2019-12-23T09:40:32.322Z","comments":true,"path":"2018/12/05/hello-world/","link":"","permalink":"http://lougazen.github.io/2018/12/05/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1hexo new \"My New Post\" More info: Writing Run server1hexo server More info: Server Generate static files1hexo generate More info: Generating Deploy to remote sites1hexo deploy More info: Deployment","categories":[],"tags":[]}]}